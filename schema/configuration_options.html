<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>GraphQL Ruby - Schema — Configuration Options</title>
    <link rel="stylesheet" href="/graphql-ruby/css/main.css">
    <link rel="icon" href="/graphql-ruby/graphql-ruby-icon.png">
    <meta name="generator">
  </head>
  <body class="hack">
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-19264608-11', 'auto');
      ga('send', 'pageview');
    </script>
    <div class="container">
      <div style="display: flex; justify-content: center;">
<strong style="white-space: pre; line-height: 1.1em; display: inline-block; font-size: 8px;">
    ▄██████▄     ▄████████    ▄████████    ▄███████▄    ▄█    █▄    ████████▄    ▄█
   ███    ███   ███    ███   ███    ███   ███    ███   ███    ███   ███    ███  ███
   ███    █▀    ███    ███   ███    ███   ███    ███   ███    ███   ███    ███  ███
  ▄███         ▄███▄▄▄▄██▀   ███    ███   ███    ███  ▄███▄▄▄▄███▄▄ ███    ███  ███
 ▀▀███ ████▄  ▀▀███▀▀▀▀▀   ▀███████████ ▀█████████▀  ▀▀███▀▀▀▀███▀  ███    ███  ███
   ███    ███ ▀███████████   ███    ███   ███          ███    ███   ███    ███  ███
   ███    ███   ███    ███   ███    ███   ███          ███    ███   ███  ▀ ███  ███▌    ▄
   ████████▀    ███    ███   ███    █▀   ▄████▀        ███    █▀     ▀██████▀▄█ █████▄▄██
                ███    ███                                                      ▀
</strong>
      </div>
      <p style="text-align: center;">A GraphQL server implementation for Ruby</p>

      <div class="grid -between">
        <div class="cell -3of12">
          <h3>Guides</h3>
          <ul>
            <li><a href="/graphql-ruby/">Getting Started</a></li>
            <li>
              <strong>Schema</strong>
              <ul>
                <li><a href="/graphql-ruby/schema/types_and_fields">Types and Fields</a></li>
                <li><a href="/graphql-ruby/schema/configuration_options">Configuration Options</a></li>
                <li><a href="/graphql-ruby/schema/code_reuse">Code Reuse</a></li>
                <li><a href="/graphql-ruby/schema/testing">Testing</a></li>
              </ul>
            </li>
            <li>
              <strong>Queries</strong>
              <ul>
                <li><a href="/graphql-ruby/queries/executing_queries">Executing Queries</a></li>
                <li><a href="/graphql-ruby/queries/authorization">Authorization</a></li>
                <li><a href="/graphql-ruby/queries/security">Security</a></li>
                <li><a href="/graphql-ruby/queries/error_handling">Error Handling</a></li>
                <li><a href="/graphql-ruby/queries/phases_of_execution">Phases of Execution</a></li>
              </ul>
            </li>
            <li>
              <strong>Relay</strong>
              <ul>
                <li><a href="/graphql-ruby/relay/object_identification">Object Identification</a></li>
                <li><a href="/graphql-ruby/relay/connections">Connections</a></li>
                <li><a href="/graphql-ruby/relay/mutations">Mutations</a></li>
              </ul>
            </li>
          </ul>
          <h3><a href="http://www.rubydoc.info/github/rmosolgo/graphql-ruby">API Docs</a></h3>
          <h3><a href="https://github.com/rmosolgo/graphql-ruby">Source Code</a></h3>
        </div>
        <div class="cell -9of12">
          <h1 class="guide-header">Schema — Configuration Options</h1>
          <p>Many things can be added to a GraphQL schema. They fall into a few categories:</p>

<ul>
  <li>Data entry points: <code class="highlighter-rouge">query</code>, <code class="highlighter-rouge">mutation</code>, <code class="highlighter-rouge">subscription</code></li>
  <li>Manually adding types: <code class="highlighter-rouge">orphan_types</code></li>
  <li>Execution functions: <code class="highlighter-rouge">resolve_type</code>, <code class="highlighter-rouge">id_from_object</code>, <code class="highlighter-rouge">object_from_id</code></li>
  <li>Security options: <code class="highlighter-rouge">max_depth</code>, <code class="highlighter-rouge">max_complexity</code></li>
  <li>Middleware: <code class="highlighter-rouge">middleware</code></li>
  <li>Query analyzers: <code class="highlighter-rouge">query_analyzer</code></li>
  <li>Execution strategies: <code class="highlighter-rouge">query_execution_strategy</code>, <code class="highlighter-rouge">mutation_execution_strategy</code>, <code class="highlighter-rouge">subscription_execution_strategy</code></li>
</ul>

<h2 id="data-entry-points">Data Entry Points</h2>

<p><code class="highlighter-rouge">query</code>, <code class="highlighter-rouge">mutation</code> and <code class="highlighter-rouge">subscriptions</code> are <a href="http://graphql.org/learn/schema/#the-query-and-mutation-types">root-level</a> <code class="highlighter-rouge">GraphQL::ObjectType</code>s.</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">QueryType</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">ObjectType</span><span class="p">.</span><span class="nf">define</span> <span class="p">{</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="p">}</span>
<span class="no">MutationType</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">ObjectType</span><span class="p">.</span><span class="nf">define</span> <span class="p">{</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="p">}</span>
<span class="no">SubscriptionType</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">ObjectType</span><span class="p">.</span><span class="nf">define</span> <span class="p">{</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="p">}</span>

<span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="c1"># required</span>
  <span class="n">query</span> <span class="no">QueryType</span>
  <span class="c1"># optional</span>
  <span class="n">mutation</span> <span class="no">MutationType</span>
  <span class="n">subscription</span> <span class="no">SubscriptionType</span>
<span class="k">end</span>
</code></pre>
</div>

<h2 id="orphan-types">Orphan Types</h2>

<p>The schema builds its type system by traversing its data entry points. In some cases, types should be present in the schema but aren’t available via traversal, so you have to add them yourself.</p>

<p>The clearest case of this is when a type implements an interface, but isn’t a return type of any other field. Since it’s not the return type of a field, it might not be found by traversal, so you can add it in <code class="highlighter-rouge">orphan_types</code>:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="c1"># ...</span>
  <span class="c1"># Make sure these types are present in the schema:</span>
  <span class="n">orphan_types</span> <span class="p">[</span><span class="no">AudioType</span><span class="p">,</span> <span class="no">VideoType</span><span class="p">,</span> <span class="no">ImageType</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
</div>

<p>It’s OK to add a type to <code class="highlighter-rouge">orphan_types</code> even if it’s already in the schema.</p>

<h2 id="execution-functions">Execution Functions</h2>

<p>During execution, a GraphQL schema may need help from you, which you can provide in these hooks:</p>

<ul>
  <li><code class="highlighter-rouge">resolve_type(obj, ctx)</code>: When we have a member of an interface or union, which object type should we use?</li>
  <li><code class="highlighter-rouge">id_from_object(object, type, ctx)</code> (Relay only): Generate a unique ID for <code class="highlighter-rouge">object</code></li>
  <li><code class="highlighter-rouge">object_from_id(id, ctx)</code> (Relay only): Given a unique ID <code class="highlighter-rouge">id</code>, return the object which it identifies</li>
</ul>

<p>These hooks are provided as objects that respond to <code class="highlighter-rouge">#call</code>, for example, a <code class="highlighter-rouge">Proc</code> literal:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="c1"># Hooks for query execution:</span>
  <span class="n">resolve_type</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="p">}</span>
  <span class="n">id_from_object</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="p">}</span>
  <span class="n">object_from_id</span> <span class="o">-&gt;</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>

<p>See <a href="/graphql-ruby/relay/object_identification">“Object Identification”</a> for more information about Relay IDs.</p>

<h2 id="security-options">Security Options</h2>

<p>These options can prevent execution of malicious queries.</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="c1"># Prevent excessively deep or complex queries</span>
  <span class="n">max_depth</span> <span class="mi">8</span>
  <span class="n">max_complexity</span> <span class="mi">120</span>
<span class="k">end</span>
</code></pre>
</div>

<p>See <a href="/graphql-ruby/queries/security">“Security”</a> for more information.</p>

<h2 id="middleware">Middleware</h2>

<p>You can use <em>middleware</em> to affect the evaluation of fields in your schema. They function like <code class="highlighter-rouge">before_action</code>s and <code class="highlighter-rouge">after_action</code>s in Rails controllers.</p>

<p>A middleware is any object that responds to <code class="highlighter-rouge">#call(*args, next_middleware)</code>. Inside that method, it should either:</p>

<ul>
  <li>send <code class="highlighter-rouge">call</code> to the next middleware to continue the evaluation; or</li>
  <li>return a value to end the evaluation early.</li>
</ul>

<p>Middlewares’ <code class="highlighter-rouge">#call</code> is invoked with several arguments:</p>

<ul>
  <li><code class="highlighter-rouge">parent_type</code> is the type whose field is being accessed</li>
  <li><code class="highlighter-rouge">parent_object</code> is the object being exposed by that type</li>
  <li><code class="highlighter-rouge">field_definition</code> is the definition for the field being accessed</li>
  <li><code class="highlighter-rouge">field_args</code> is the hash of arguments passed to the field</li>
  <li><code class="highlighter-rouge">query_context</code> is the context object passed throughout the query</li>
  <li><code class="highlighter-rouge">next_middleware</code> represents the execution chain. Call <code class="highlighter-rouge">#call</code> to continue evalution.</li>
</ul>

<p>Add a middleware to a schema by adding to the <code class="highlighter-rouge">#middleware</code> array.</p>

<h3 id="example-authorization">Example: Authorization</h3>

<p>This middleware only continues evaluation if the <code class="highlighter-rouge">current_user</code> is permitted to read the target object:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AuthorizationMiddleware</span>
  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">parent_type</span><span class="p">,</span> <span class="n">parent_object</span><span class="p">,</span> <span class="n">field_definition</span><span class="p">,</span> <span class="n">field_args</span><span class="p">,</span> <span class="n">query_context</span><span class="p">,</span> <span class="n">next_middleware</span><span class="p">)</span>
    <span class="n">current_user</span> <span class="o">=</span> <span class="n">query_context</span><span class="p">[</span><span class="ss">:current_user</span><span class="p">]</span> <span class="c1"># passed in when creating the query</span>
    <span class="k">if</span> <span class="n">current_user</span> <span class="o">&amp;&amp;</span> <span class="n">current_user</span><span class="p">.</span><span class="nf">can_read?</span><span class="p">(</span><span class="n">parent_object</span><span class="p">)</span>
      <span class="c1"># This user is authorized, so continue execution</span>
      <span class="n">next_middleware</span><span class="p">.</span><span class="nf">call</span>
    <span class="k">else</span>
      <span class="c1"># Silently halt execution</span>
      <span class="kp">nil</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Then, add the middleware to your schema:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="n">middleware</span> <span class="no">AuthorizationMiddleware</span><span class="p">.</span><span class="nf">new</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Now, all field access will be wrapped by that authorization routine.</p>

<h2 id="query-analyzers">Query Analyzers</h2>

<p>Query analyzers are like middleware for the validation phase. They’re called at each node of the query’s internal representation (see <code class="highlighter-rouge">GraphQL::InternalRepresentation::Node</code>). If they return a <code class="highlighter-rouge">GraphQL::AnalysisError</code> (or an array of those errors), the query won’t be run and the error will be added to the response’s <code class="highlighter-rouge">errors</code> key.</p>

<p>The minimal API is <code class="highlighter-rouge">.call(memo, visit_type, internal_representation_node)</code>. For example:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">ast_node_logger</span> <span class="o">=</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">memo</span><span class="p">,</span> <span class="n">visit_type</span><span class="p">,</span> <span class="n">internal_representation_node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">visit_type</span> <span class="o">==</span> <span class="ss">:enter</span>
    <span class="nb">puts</span> <span class="s2">"Visiting </span><span class="si">#{</span><span class="n">internal_representation_node</span><span class="p">.</span><span class="nf">name</span><span class="si">}</span><span class="s2">!"</span>
  <span class="k">end</span>
<span class="p">}</span>
<span class="no">MySchema</span><span class="p">.</span><span class="nf">query_analyzers</span> <span class="o">&lt;&lt;</span> <span class="n">ast_node_logger</span>
</code></pre>
</div>

<p>Whatever <code class="highlighter-rouge">.call(...)</code> returns will be passed as <code class="highlighter-rouge">memo</code> for the next visit.</p>

<p>The analyzer can implement a few <strong>other methods</strong>. If they’re present, they’ll be called:</p>

<ul>
  <li><code class="highlighter-rouge">.initial_value(query)</code> will be called to generate an initial value for <code class="highlighter-rouge">memo</code></li>
  <li><code class="highlighter-rouge">.final_value(memo)</code> will be called <em>after</em> visiting the the query</li>
</ul>

<p>If the last value of <code class="highlighter-rouge">memo</code> (or the return of <code class="highlighter-rouge">.final_value</code>) is a <code class="highlighter-rouge">GraphQL::AnalysisError</code>, the query won’t be executed and the error will be added to the <code class="highlighter-rouge">errors</code> key of the response.</p>

<p><code class="highlighter-rouge">graphql-ruby</code> includes a few query analyzers:</p>

<ul>
  <li><code class="highlighter-rouge">GraphQL::Analysis::QueryDepth</code> and <code class="highlighter-rouge">GraphQL::Analysis::QueryComplexity</code> for inspecting query depth and complexity</li>
  <li><code class="highlighter-rouge">GraphQL::Analysis::MaxQueryDepth</code> and <code class="highlighter-rouge">GraphQL::Analysis::MaxQueryComplexity</code> are used internally to implement <code class="highlighter-rouge">max_depth:</code> and <code class="highlighter-rouge">max_complexity:</code> options</li>
</ul>

<h2 id="execution-strategies">Execution Strategies</h2>

<p><code class="highlighter-rouge">graphql</code> includes a serial execution strategy, but you can also create custom strategies to support advanced behavior. See <code class="highlighter-rouge">GraphQL::SerialExecution#execute</code> the required behavior.</p>

<p>Then, set your schema to use your custom execution strategy with <code class="highlighter-rouge">GraphQL::Schema#{query|mutation|subscription}_execution_strategy</code></p>

<p>For example:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CustomQueryExecutionStrategy</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="n">operation_name</span><span class="p">,</span> <span class="n">root_type</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># ... define your types ...</span>

<span class="no">MySchema</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="n">query</span> <span class="no">MyQueryType</span>
  <span class="n">mutation</span> <span class="no">MyMutationType</span>
  <span class="c1"># Use your custom strategy:</span>
  <span class="n">query_execution_strategy</span> <span class="no">CustomQueryExecutionStrategy</span>
<span class="k">end</span>
</code></pre>
</div>

        </div>
      </div>
    </div>
    <script>
      // Find headers with IDs and wrap their text in `<a href=></a>`
      // That way people can easily copy the link.
      var headers = document.querySelectorAll("h1, h2, h3, h4, h5");
      var header, idText, headerLink;
      for (var i = 0; i < headers.length; i++) {
        header = headers[i];
        idText = header.id;
        if (idText) {
          headerLink = document.createElement("a");
          headerLink.href = "#" + idText;
          headerLink.textContent = header.textContent;
          header.textContent = "";
          header.appendChild(headerLink);
        }
      }
    </script>
  </body>
</html>
