<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta http-equiv="refresh" content="1;url=http://www.rubydoc.info/gems/graphql/GraphQL/Field" />
  </head>
  <body>
    <p>Class: GraphQL::Field &lt; Object
{Field}s belong to {ObjectType}s and  They’re usually created with
the <code class="highlighter-rouge">field</code> helper. If you create it by hand, make sure {#name is a
String. 
A field must have a return type, but if you want to defer the return
type calculation until later, you can pass a proc for the return
type. That proc will be called when the schema is defined. 
For complex field definition, you can pass a block to the <code class="highlighter-rouge">field</code>
helper, eg <code class="highlighter-rouge">field :name do ... end</code>. This block is equivalent to
calling <code class="highlighter-rouge">GraphQL::Field.define { ... }</code>. 
## Resolve 
Fields have <code class="highlighter-rouge">resolve</code> functions to determine their values at
query-time. The default implementation is to call a method on the
object based on the field name. 
You can specify a custom proc with the <code class="highlighter-rouge">resolve</code> helper. 
There are some shortcuts for common <code class="highlighter-rouge">resolve</code> implementations:
- Provide <code class="highlighter-rouge">property:</code> to call a method with a different name than
the field name
- Provide <code class="highlighter-rouge">hash_key:</code> to resolve the field by doing a key lookup,
eg <code class="highlighter-rouge">obj[:my_hash_key]</code>
## Arguments 
Fields can take inputs; they’re called arguments. You can define
them with the <code class="highlighter-rouge">argument</code> helper. 
They can have default values which will be provided to <code class="highlighter-rouge">resolve</code> if
the query doesn’t include a value. 
Only certain types maybe used for inputs: 
- Scalars - Enums - Input Objects - Lists of those types 
Input types may also be non-null   in that case, the query will
fail if the input is not present. 
## Complexity 
Fields can have <em>complexity</em> values which describe the computation
cost of resolving the field. You can provide the complexity as a
constant with <code class="highlighter-rouge">complexity:</code> or as a proc, with the <code class="highlighter-rouge">complexity</code>
helper. 
Examples:
# Lazy type resolution
# If the field’s type isn’t defined yet, you can pass a proc
field :city, -&gt; { TypeForModelName.find(“City”) }
# Defining a field with a block
field :city, CityType do
# field definition continues inside the block
end
# Create a field which calls a method with the same name.
GraphQL::ObjectType.define do
field :name, types.String, “The name of this thing “
end
# Create a field that calls a different method on the object
GraphQL::ObjectType.define do
# use the <code class="highlighter-rouge">property</code> keyword:
field :firstName, types.String, property: :first_name
end
# Create a field looks up with <code class="highlighter-rouge">[hash_key]</code>
GraphQL::ObjectType.define do
# use the <code class="highlighter-rouge">hash_key</code> keyword:
field :firstName, types.String, hash_key: :first_name
end
# Create a field with an argument
field :students, types[StudentType] do
argument :grade, types.Int
resolve -&gt;(obj, args, ctx) {
Student.where(grade: args[:grade])
}
end
# Argument with a default value
field :events, types[EventType] do
# by default, don’t include past events
argument :includePast, types.Boolean, default_value: false
resolve -&gt;(obj, args, ctx) {
args[:includePast] # =&gt; false if no value was provided in the query
# …
}
end
# Custom complexity values
# Complexity can be a number or a proc.
# Complexity can be defined with a keyword:
field :expensive_calculation, !types.Int, complexity: 10
# Or inside the block:
field :expensive_calculation_2, !types.Int do
complexity -&gt;(ctx, args, child_complexity) { ctx[:current_user].staff? ? 0 : 10 }
end
# Calculating the complexity of a list field
field :items, types[ItemType] do
argument :limit, !types.Int
# Mulitply the child complexity by the possible items on the list
complexity -&gt;(ctx, args, child_complexity) { child_complexity * args[:limit] }
end
# Creating a field, then assigning it to a type
name_field = GraphQL::Field.define do
name(“Name”)
type(!types.String)
description(“The name of this thing”)
resolve -&gt;(object, arguments, context) { object.name }
end
NamedType = GraphQL::ObjectType.define do
# The second argument may be a GraphQL::Field
field :name, name_field
end
Includes:
GraphQL::Define::InstanceDefinable
Instance methods:
build_default_resolver, connection?, default_arguments, initialize,
initialize_copy, lazy_resolve, lazy_resolve=, prepare_lazy, resolve,
resolve=, to_s, type, type=</p>


  </body>
</html>
