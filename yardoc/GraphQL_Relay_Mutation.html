<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta http-equiv="refresh" content="1;url=http://www.rubydoc.info/gems/graphql/1.7.6/GraphQL/Relay/Mutation" />
  </head>
  <body>
    <p>Class: GraphQL::Relay::Mutation &lt; Object
Define a Relay mutation:</p>
<ul>
  <li>give it a name (used for derived inputs &amp; outputs)</li>
  <li>declare its inputs</li>
  <li>declare its outputs</li>
  <li>declare the mutation procedure
<code class="highlighter-rouge">resolve</code> should return a hash with a key for each of the
<code class="highlighter-rouge">return_field</code>s 
Inputs may also contain a <code class="highlighter-rouge">clientMutationId</code> 
Examples:
    <h1 id="updating-the-name-of-an-item">Updating the name of an item</h1>
    <p>UpdateNameMutation = GraphQL::Relay::Mutation.define do
name “UpdateName”
input_field :name, !types.String
input_field :itemId, !types.ID
return_field :item, ItemType
resolve -&gt;(inputs, ctx) {
item = Item.find_by_id(inputs[:id])
item.update(name: inputs[:name])
{item: item}
}
end
MutationType = GraphQL::ObjectType.define do</p>
    <h1 id="the-mutation-object-exposes-a-field">The mutation object exposes a field:</h1>
    <p>field :updateName, field: UpdateNameMutation.field
end</p>
    <h1 id="then-query-it">Then query it:</h1>
    <p>query_string = %|
mutation updateName {
updateName(input: {itemId: 1, name: “new name”, clientMutationId: “1234”}) {
item { name }
clientMutationId
}|
GraphQL::Query.new(MySchema, query_string).result</p>
    <h1 id="data--">{“data” =&gt; {</h1>
    <h1 id="updatename--">“updateName” =&gt; {</h1>
    <h1 id="item---name--new-name">“item” =&gt; { “name” =&gt; “new name”},</h1>
    <h1 id="clientmutationid--1234">“clientMutationId” =&gt; “1234”</h1>
    <h1>}</h1>
    <h1 id="-1">}}</h1>
    <h1 id="using-a-graphqlfunction">Using a GraphQL::Function</h1>
    <p>class UpdateAttributes &lt; GraphQL::Function
attr_reader :model, :return_as, :arguments
def initialize(model:, return_as:, attributes:)
@model = model
@arguments = {}
attributes.each do |name, type|
arg_name = name.to_s
@arguments[arg_name] = GraphQL::Argument.define(name: arg_name, type: type)
end
@arguments[“id”] = GraphQL::Argument.define(name: “id”, type: !GraphQL::ID_TYPE)
@return_as = return_as
@attributes = attributes
end
def type
fn = self
GraphQL::ObjectType.define do
name “Update#{fn.model.name}AttributesResponse”
field :clientMutationId, types.ID
field fn.return_as.keys[0], fn.return_as.values[0]
end
end
def call(obj, args, ctx)
record = @model.find(args[:inputs][:id])
new_values = {}
@attributes.each { |a| new_values[a] = args[a] }
record.update(new_values)
{ @return_as =&gt; record }
end
end
UpdateNameMutation = GraphQL::Relay::Mutation.define do
name “UpdateName”
function UpdateAttributes.new(model: Item, return_as: { item: ItemType }, attributes: {name: !types.String})
end
Includes:
GraphQL::Define::InstanceDefinable
Instance methods:
field, get_arity, has_generated_return_type?, initialize,
input_type, resolve=, result_class</p>
  </li>
</ul>


  </body>
</html>
